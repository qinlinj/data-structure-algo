package org.qinlinj.algoframework._700_brute_force_search_algo._750_bfs_algo._753_bfs_classic_practice_II; /**
 * Minimize Malware Spread (LeetCode 924)
 * -------------------------------------
 * <p>
 * Summary:
 * This problem involves a network of nodes represented as an adjacency matrix. Initially,
 * some nodes are infected with malware. Malware spreads to adjacent nodes until no more
 * can be infected. The goal is to determine which initially infected node, if removed,
 * would minimize the total number of infected nodes after the spread.
 * <p>
 * Key Concepts:
 * 1. Connected components in a graph
 * 2. BFS to explore connected components
 * 3. Tracking infection spread with and without specific nodes
 * 4. Finding the most influential node in the malware spread
 * <p>
 * Approach:
 * - For each initially infected node, perform BFS to find its connected component
 * - Count how many infected nodes are in each connected component
 * - For components with exactly one infected node, removing this node prevents infection
 * in the entire component
 * - Choose the node that, when removed, saves the most nodes from infection
 * - If multiple nodes meet the criteria, choose the one with the smallest index
 * <p>
 * Time Complexity: O(nÂ³) where n is the number of nodes (due to BFS for each infected node)
 * Space Complexity: O(n) for the queue and visited array
 */

import java.util.*;

public class _753_b_MinimizeMalwareSpread {

    /**
     * Example usage
     */
    public static void main(String[] args) {
        _753_b_MinimizeMalwareSpread solution = new _753_b_MinimizeMalwareSpread();

        // Example 1: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
        int[][] graph1 = {
                {1, 1, 0},
                {1, 1, 0},
                {0, 0, 1}
        };
        int[] initial1 = {0, 1};
        System.out.println("Example 1: " + solution.minMalwareSpread(graph1, initial1)); // Expected: 0

        // Example 2: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
        int[][] graph2 = {
                {1, 0, 0},
                {0, 1, 0},
                {0, 0, 1}
        };
        int[] initial2 = {0, 2};
        System.out.println("Example 2: " + solution.minMalwareSpread(graph2, initial2)); // Expected: 0

        // Example 3: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
        int[][] graph3 = {
                {1, 1, 1},
                {1, 1, 1},
                {1, 1, 1}
        };
        int[] initial3 = {1, 2};
        System.out.println("Example 3: " + solution.minMalwareSpread(graph3, initial3)); // Expected: 1

        // Additional example with larger graph
        int[][] graph4 = {
                {1, 1, 0, 0, 0},
                {1, 1, 0, 0, 0},
                {0, 0, 1, 1, 0},
                {0, 0, 1, 1, 0},
                {0, 0, 0, 0, 1}
        };
        int[] initial4 = {0, 2, 4};
        System.out.println("Additional Example: " + solution.minMalwareSpread(graph4, initial4));
    }

    /**
     * Find the node to remove to minimize malware spread
     * @param graph Adjacency matrix where graph[i][j] = 1 means nodes i and j are connected
     * @param initial Array of initially infected nodes
     * @return The node to remove
     */
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;

        // Convert initial array to a set for O(1) lookups
        Set<Integer> initialSet = new HashSet<>();
        for (int node : initial) {
            initialSet.add(node);
        }

        // Sort initial array to ensure we pick the smallest index if there's a tie
        Arrays.sort(initial);

        boolean[] visited = new boolean[n];
        int targetNode = initial[0]; // Default to the smallest index
        int maxReduction = 0;        // Track the maximum number of nodes saved

        // Try removing each initially infected node
        for (int badNode : initial) {
            if (visited[badNode]) {
                continue; // Skip already visited nodes
            }

            // BFS to find the connected component and count infected nodes
            int[] counts = bfs(graph, badNode, visited, initialSet);
            int nodesInComponent = counts[0];
            int infectedInComponent = counts[1];

            // If there's only one infected node in this component
            if (infectedInComponent == 1) {
                // Removing it would save all nodes in the component
                if (nodesInComponent > maxReduction) {
                    maxReduction = nodesInComponent;
                    targetNode = badNode;
                }
            }
        }

        return targetNode;
    }

    /**
     * BFS to find connected component and count infected nodes
     * @param graph Adjacency matrix
     * @param startNode Starting node for BFS
     * @param visited Global visited array
     * @param initialSet Set of initially infected nodes
     * @return int[] where [0] = total nodes in component, [1] = infected nodes in component
     */
    private int[] bfs(int[][] graph, int startNode, boolean[] visited, Set<Integer> initialSet) {
        int n = graph.length;
        visited[startNode] = true;

        int nodeCount = 0;  // Total nodes in the component
        int badCount = 0;   // Initially infected nodes in the component

        Queue<Integer> queue = new LinkedList<>();
        queue.offer(startNode);

        while (!queue.isEmpty()) {
            int node = queue.poll();
            nodeCount++;

            if (initialSet.contains(node)) {
                badCount++;
            }

            // Explore adjacent nodes
            for (int neighbor = 0; neighbor < n; neighbor++) {
                if (graph[node][neighbor] == 1 && !visited[neighbor]) {
                    queue.offer(neighbor);
                    visited[neighbor] = true;
                }
            }
        }

        return new int[]{nodeCount, badCount};
    }
}